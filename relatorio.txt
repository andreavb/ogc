MC011 - Prof. Sandro Rigo
Primeiro Projeto - 13/04/2009

Alunos

Andrea Vidigal Bucci - ra023157
Franz Glauber Vanderlinde - ra043648 

1 Objetivo

       O objetivo do projeto era a implementação da etapa de Análise
Semântica para a linguagem minijava.

2 Implementação

       Segundo sugestão dada em sala de aula, optamos por dividir o projeto
em duas passagens.
       A primeira dela consiste na criação da tabela de símbolos, enquanto a
segunda se responsabiliza pela checagem de tipos.
       A primeira passagem recebe o programa e o parseia, começando pelo
método principal. Todos os objetos do programa (classes, métodos,
atributos, variáveis locais, parâmetros dos métodos) são percorridos e
colocados na tabela de símbolos. A seguir, realiza-se uma verificação
inicial, que detecta classes e métodos que foram redeclarados,
variáveis com tipagem redefinida, e heranças cíclicas.
       A segunda passagem trata da verificação de tipos, isto é, se os tipos
de parâmetro e retorno foram respeitados ao longo do programa. Esta
verificação não interrompe a compilação ao encontrar um erro. Desta
forma, torna-se possível a exibição de todos os erros do programa
analisado.

       Para detecção de herança cíclica, nós listamos primeiramente as
classes órfãs, isto é, que não herdam de ninguém. A seguir,
completamos a lista com as classes que herdam de classes que já
pertencem à lista.
       Desta forma, as classes que participam de ciclos de herança
jamais serão colocadas na lista, pois não herdam, direta ou
indiretamente (por transitividade) de classes órfãs.
        Este algoritmo é uma simplificação do encontrado em uma referência[2] sobre
Topological Sort. A busca topológica visa montar a hierarquia de classes,
armazenando em d[i] todos os filhos das classes que estão em d[i-1].
Para o nosso projeto, no entanto, a hierarquia é importante somente
para verificação de herança cíclica. Por esta razão, construímos uma
lista única (em que as classes aparecem ordenadas topologicamente),
sem nos preocuparmos com a separação por níveis. 

2.1 Conteúdo do pacote semant:

O arquivo tar conta com um diretório de nome semant, onde se encontra
a seguinte estrutura de arquivos:
Env.java: esta classe não foi alterada.
TypeChecker.java: esta classe foi recebida e alterada de modo a
disparar a execução das duas etapas do analisador semântico. Cria o
ambiente de erros, a tabela de classes do programa e a seguir chama as
duas passagens.
PrimeiraPassagem.java: Montagem da tabela de símbolos.
SegundaPassagem.java: Verificação de tipos.
testes: diretório baixado da página da disciplina. Anexados a este
diretório, os resultados dos testes.
/* FIXME */
nomedoscript.sh: automatizador da compilação e execução do projeto.

2.2 Utilização do pacote semant:

2.2.1 Extração:
O compilador completo está no arquivo proj1g05.tar.gz
$ tar xzf proj1g05.tar.gz

2.2.2 Compilação:
/* FIXME */
$ javac semant/ ???

2.2.3 Utilização:
A execução do analisador semântico para os testes dá-se na forma:
$ java main.Main < arq.in
onde arq.in é o arquivo de testes considerado.
A saída será nula se o arquivo de testes passar pelo analisador
semântico, ou conterá as mensagens de erro, caso o arquivo apresente
problemas.

2.2.4 Automatização:

/* FIXME */
Para automatizar a extração, compilação e execução do programa, nós
elaboramos o scrip nomedoscript.sh.
Este script verifica os programas passados como parâmetro e gera os
resultados no formato "X.out", no mesmo diretório do arquivo de teste
"X", em vez de na saída padrão.

Execução do script, após a extração do pacote do compilador:
$ cd proj1g05
/* FIXME */
$ ./nomedoscript.sh

3 Testes e resultados:

Testamos o nosso projeto com os arquivos disponíveis na página da disciplina.
Sem nos depararmos com nenhuma surpresa, encontramos o resultado
esperado para cada um dos testes.

4 Referências

[1] Modern Compiler Implementation in Java - Andrew W. Appel - Second Edition
[2] http://tecomp.wiki.sourceforge.net/Topological+sort
